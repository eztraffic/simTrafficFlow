<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 場景編輯器 (含內嵌模型功能)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            height: 100vh;
            color: #333;
        }

        #sidebar {
            width: 320px;
            background: #2c3e50;
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #1a252f;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .panel {
            padding: 15px;
            border-bottom: 1px solid #34495e;
        }

        .panel h3 {
            margin-top: 0;
            font-size: 1.1em;
            color: #3498db;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
            display: inline-block;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            font-weight: bold;
        }

        input[type="file"],
        input[type="text"] {
            width: 100%;
            margin-bottom: 10px;
            box-sizing: border-box;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        input[type="file"] {
            background: #fff;
            color: #333;
        }

        button {
            background-color: #2980b9;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 5px;
            transition: background 0.2s;
            font-size: 0.9em;
        }

        button:hover {
            background-color: #3498db;
        }

        button.action-btn {
            background-color: #27ae60;
            font-weight: bold;
            margin-top: 10px;
        }

        button.action-btn:hover {
            background-color: #2ecc71;
        }

        button.delete-btn {
            background-color: #c0392b;
            margin-top: 5px;
        }

        button.delete-btn:hover {
            background-color: #e74c3c;
        }

        .mode-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .mode-btn {
            flex: 1;
            background: #34495e;
            color: #ccc;
            border: 1px solid #444;
        }

        .mode-btn.active {
            background: #e67e22;
            color: #fff;
            border-color: #d35400;
        }

        #object-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            background: #233140;
        }

        .obj-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #34495e;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85em;
        }

        .obj-item:hover {
            background: #3e5871;
        }

        .obj-item.selected {
            border: 1px solid #e67e22;
            background: #2c3e50;
        }

        .obj-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 180px;
        }

        #viewport {
            flex: 1;
            position: relative;
            background: #444;
        }

        #loading-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 20;
            font-size: 1.5em;
        }
    </style>

    <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/controls/TransformControls.js"></script>
</head>

<body>

    <div id="sidebar">
        <div class="panel">
            <h3>1. 專案設定</h3>
            <label>載入路網 (SIM/XML):</label>
            <input type="file" id="xmlInput" accept=".sim,.xml">

            <label style="margin-top:10px; color:#f39c12;">匯入已存場景 (XML):</label>
            <input type="file" id="importSceneInput" accept=".xml">
            <div id="status-text" style="font-size:0.8em; color:#bdc3c7;">尚未載入</div>
        </div>

        <div class="panel">
            <h3>2. 加入模型</h3>
            <label>選擇 GLB/GLTF (將內嵌):</label>
            <input type="file" id="glbInput" accept=".glb,.gltf">
        </div>

        <div class="panel">
            <h3>3. 編輯工具</h3>
            <div class="mode-controls">
                <button class="mode-btn active" onclick="setTransformMode('translate')">移動</button>
                <button class="mode-btn" onclick="setTransformMode('rotate')">旋轉</button>
                <button class="mode-btn" onclick="setTransformMode('scale')">縮放</button>
            </div>
            <label>物件名稱:</label>
            <input type="text" id="selectedName" disabled style="background:#ddd;">
            <button class="delete-btn" onclick="deleteSelected()">刪除物件</button>
        </div>

        <div id="object-list"></div>

        <div class="panel" style="margin-top: auto;">
            <h3>4. 輸出</h3>
            <button class="action-btn" onclick="exportSceneXML()">匯出完整場景 XML</button>
        </div>
    </div>

    <div id="viewport">
        <div id="loading-mask">處理中...</div>
    </div>

    <script>
        let scene, camera, renderer, orbitControls, transformControl;
        let networkGroup, basemapGroup, userModelsGroup;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let selectedObject = null;

        // --- Utils ---
        function findChildren(parent, tagName) {
            if (!parent) return [];
            const arr = [];
            const all = parent.getElementsByTagName('*');
            for (let i = 0; i < all.length; i++) {
                const local = all[i].localName || all[i].nodeName.split(':').pop();
                if (local === tagName) arr.push(all[i]);
            }
            return arr;
        }

        function getVal(parent, tagName) {
            const nodes = findChildren(parent, tagName);
            return nodes.length > 0 ? nodes[0].textContent : null;
        }

        // --- Init ---
        function init() {
            const container = document.getElementById('viewport');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            const gridHelper = new THREE.GridHelper(5000, 100, 0x555555, 0x222222);
            gridHelper.position.y = -0.05; scene.add(gridHelper);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            hemiLight.position.set(0, 200, 0); scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(100, 200, 50); dirLight.castShadow = true; scene.add(dirLight);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 10000);
            camera.position.set(0, 200, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);

            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;

            transformControl = new THREE.TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('dragging-changed', e => orbitControls.enabled = !e.value);
            scene.add(transformControl);

            networkGroup = new THREE.Group();
            basemapGroup = new THREE.Group();
            userModelsGroup = new THREE.Group();
            scene.add(networkGroup); scene.add(basemapGroup); scene.add(userModelsGroup);

            window.addEventListener('resize', onWindowResize);
            container.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('keydown', onKeyDown);
            animate();
        }

        function animate() { requestAnimationFrame(animate); orbitControls.update(); renderer.render(scene, camera); }
        function onWindowResize() {
            const c = document.getElementById('viewport');
            camera.aspect = c.clientWidth / c.clientHeight;
            camera.updateProjectionMatrix(); renderer.setSize(c.clientWidth, c.clientHeight);
        }

        // --- Interaction ---
        function onPointerDown(e) {
            const c = document.getElementById('viewport');
            const r = c.getBoundingClientRect();
            mouse.x = ((e.clientX - r.left) / c.clientWidth) * 2 - 1;
            mouse.y = -((e.clientY - r.top) / c.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(userModelsGroup.children, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && obj.parent !== userModelsGroup) obj = obj.parent;
                if (obj !== selectedObject) selectObject(obj);
            } else if (!transformControl.dragging) selectObject(null);
        }

        function onKeyDown(e) {
            if (e.target.tagName === 'INPUT') return;
            switch (e.key.toLowerCase()) {
                case 'w': setTransformMode('translate'); break;
                case 'e': setTransformMode('rotate'); break;
                case 'r': setTransformMode('scale'); break;
                case 'delete': case 'backspace': deleteSelected(); break;
            }
        }

        function setTransformMode(m) {
            transformControl.setMode(m);
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const map = { 'translate': 0, 'rotate': 1, 'scale': 2 };
            document.querySelectorAll('.mode-btn')[map[m]].classList.add('active');
        }

        function selectObject(obj) {
            selectedObject = obj;
            if (obj) {
                transformControl.attach(obj);
                document.getElementById('selectedName').value = obj.userData.fileName;
            } else {
                transformControl.detach();
                document.getElementById('selectedName').value = '';
            }
            renderObjectList();
        }

        function deleteSelected() {
            if (selectedObject) {
                transformControl.detach();
                userModelsGroup.remove(selectedObject);
                selectObject(null);
            }
        }

        function renderObjectList() {
            const list = document.getElementById('object-list');
            list.innerHTML = '';
            userModelsGroup.children.forEach(obj => {
                const div = document.createElement('div');
                div.className = 'obj-item' + (obj === selectedObject ? ' selected' : '');
                div.innerHTML = `<span class="obj-name">${obj.userData.fileName}</span>`;
                div.onclick = (e) => { e.stopPropagation(); selectObject(obj); };
                list.appendChild(div);
            });
        }

        // --- Add Model (Embed Base64) ---
        const glbInput = document.getElementById('glbInput');
        glbInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const loadingMask = document.getElementById('loading-mask');
            loadingMask.style.display = 'flex';

            // 1. Read file as Data URL (Base64) to store in XML later
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = (evt) => {
                const base64String = evt.target.result; // "data:application/octet-stream;base64,..."

                // 2. Load into Three.js scene
                const loader = new THREE.GLTFLoader();
                loader.load(base64String, (gltf) => {
                    const model = gltf.scene;
                    model.userData.fileName = file.name;
                    // Store the full Data URL string for export
                    model.userData.base64 = base64String;

                    model.position.copy(orbitControls.target);
                    model.position.y += 0.5;
                    model.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });

                    userModelsGroup.add(model);
                    selectObject(model);
                    loadingMask.style.display = 'none';
                    glbInput.value = '';
                }, undefined, (err) => {
                    console.error(err);
                    alert('模型載入失敗');
                    loadingMask.style.display = 'none';
                });
            };
        });

        // --- Import Previous Scene XML ---
        const importSceneInput = document.getElementById('importSceneInput');
        importSceneInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const loadingMask = document.getElementById('loading-mask');
            loadingMask.style.display = 'flex';

            const reader = new FileReader();
            reader.onload = (evt) => {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(evt.target.result, "application/xml");

                if (xmlDoc.getElementsByTagName("parsererror").length) {
                    alert("XML 格式錯誤");
                    loadingMask.style.display = 'none';
                    return;
                }

                // Restore Objects
                userModelsGroup.clear();
                const models = findChildren(xmlDoc, 'StaticModel');
                let pending = models.length;

                if (pending === 0) {
                    loadingMask.style.display = 'none';
                    return;
                }

                const loader = new THREE.GLTFLoader();

                models.forEach(modelEl => {
                    const name = getVal(modelEl, 'FileName') || 'Unknown';
                    const b64 = getVal(modelEl, 'BinaryData'); // Get embedded data

                    // Get TRS
                    const posEl = findChildren(modelEl, 'Position')[0];
                    const rotEl = findChildren(modelEl, 'Rotation')[0];
                    const sclEl = findChildren(modelEl, 'Scale')[0];

                    const xmlX = parseFloat(posEl.getAttribute('x'));
                    const xmlY = parseFloat(posEl.getAttribute('y'));
                    const xmlZ = parseFloat(posEl.getAttribute('z'));

                    // Restore Coord: Sim -> Three
                    // Sim Load: threeX = xmlX, threeZ = -xmlY, threeY = xmlZ
                    const px = xmlX;
                    const py = xmlZ;
                    const pz = -xmlY;

                    if (b64) {
                        loader.load(b64, (gltf) => {
                            const mesh = gltf.scene;
                            mesh.userData.fileName = name;
                            mesh.userData.base64 = b64; // Restore data for re-export

                            mesh.position.set(px, py, pz);
                            mesh.rotation.set(
                                parseFloat(rotEl.getAttribute('x')),
                                parseFloat(rotEl.getAttribute('y')),
                                parseFloat(rotEl.getAttribute('z'))
                            );
                            mesh.scale.set(
                                parseFloat(sclEl.getAttribute('x')),
                                parseFloat(sclEl.getAttribute('y')),
                                parseFloat(sclEl.getAttribute('z'))
                            );

                            mesh.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
                            userModelsGroup.add(mesh);

                            pending--;
                            if (pending === 0) {
                                loadingMask.style.display = 'none';
                                renderObjectList();
                            }
                        }, undefined, (err) => {
                            console.error("Failed to load embedded model", err);
                            pending--;
                            if (pending === 0) loadingMask.style.display = 'none';
                        });
                    } else {
                        pending--;
                    }
                });
                importSceneInput.value = '';
            };
            reader.readAsText(file);
        });

        // --- Export XML (With Base64) ---
        function exportSceneXML() {
            if (userModelsGroup.children.length === 0) { alert('無模型可匯出'); return; }

            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n<SceneObjects>\n';

            userModelsGroup.children.forEach(obj => {
                const pos = obj.position;
                const rot = obj.rotation;
                const scl = obj.scale;

                // Coord Conversion: Three -> Sim
                // xmlX = x, xmlY = -z, xmlZ = y
                const xmlX = pos.x;
                const xmlY = -pos.z;
                const xmlZ = pos.y;

                // Remove standard base64 prefix if you want raw data, 
                // but keeping it as Data URL is safer for <img> src or GLTFLoader directly.
                // XML text content handles large strings fine.
                const b64Data = obj.userData.base64 || "";

                xml += `    <StaticModel>\n` +
                    `        <FileName>${obj.userData.fileName}</FileName>\n` +
                    `        <Position x="${xmlX.toFixed(4)}" y="${xmlY.toFixed(4)}" z="${xmlZ.toFixed(4)}" />\n` +
                    `        <Rotation x="${rot.x.toFixed(4)}" y="${rot.y.toFixed(4)}" z="${rot.z.toFixed(4)}" />\n` +
                    `        <Scale x="${scl.x.toFixed(4)}" y="${scl.y.toFixed(4)}" z="${scl.z.toFixed(4)}" />\n` +
                    `        <BinaryData>${b64Data}</BinaryData>\n` +
                    `    </StaticModel>\n`;
            });

            xml += '</SceneObjects>';

            const url = URL.createObjectURL(new Blob([xml], { type: 'text/xml' }));
            const a = document.createElement('a');
            a.href = url; a.download = 'scene_data.xml'; a.click();
            URL.revokeObjectURL(url);
        }

        // --- Network Parser (Standard) ---
        const xmlInput = document.getElementById('xmlInput');
        xmlInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(evt.target.result, "application/xml");
                if (xmlDoc.getElementsByTagName("parsererror").length) { alert("XML 錯誤"); return; }

                networkGroup.clear(); basemapGroup.clear();

                parseNetwork(xmlDoc).then(bounds => {
                    if (bounds.minX !== Infinity) {
                        const cx = (bounds.minX + bounds.maxX) / 2;
                        const cy = (bounds.minY + bounds.maxY) / 2;
                        const size = Math.max(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
                        camera.position.set(cx, size, cy + size);
                        orbitControls.target.set(cx, 0, cy);
                        orbitControls.update();
                    }
                    document.getElementById('status-text').textContent = `已載入: ${file.name}`;
                });
            };
            reader.readAsText(file);
        });

        function parseNetwork(xmlDoc) {
            return new Promise(resolve => {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                const updateBounds = (x, y) => { minX = Math.min(minX, x); minY = Math.min(minY, y); maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); };
                const roadMat = new THREE.MeshLambertMaterial({ color: 0x555555, side: THREE.DoubleSide });
                const juncMat = new THREE.MeshLambertMaterial({ color: 0x666666, side: THREE.DoubleSide });

                // Links
                const links = findChildren(xmlDoc, 'Link'); // simplified approach
                // If findChildren fails due to root level, try traversing all
                const all = xmlDoc.getElementsByTagName('*');
                for (let i = 0; i < all.length; i++) {
                    const name = all[i].localName || all[i].nodeName.split(':').pop();
                    if (name === 'Link') {
                        // Find TrapSegs
                        const traps = findChildren(all[i], 'TrapeziumSegment'); // This assumes direct child or simple structure
                        // Fallback: search descendants
                        const desc = all[i].getElementsByTagName('*');
                        for (let j = 0; j < desc.length; j++) {
                            const dName = desc[j].localName || desc[j].nodeName.split(':').pop();
                            if (dName === 'TrapeziumSegment') {
                                const getPt = (s, e) => {
                                    const sNode = findChildren(desc[j], s)[0];
                                    const eNode = findChildren(sNode, e)[0];
                                    const x = parseFloat(getVal(eNode, 'x'));
                                    const y = -parseFloat(getVal(eNode, 'y'));
                                    updateBounds(x, y); return { x, y };
                                };
                                const p1 = getPt('LeftSide', 'Start'), p2 = getPt('RightSide', 'Start'), p3 = getPt('RightSide', 'End'), p4 = getPt('LeftSide', 'End');
                                const shape = new THREE.Shape(); shape.moveTo(p1.x, -p1.y); shape.lineTo(p2.x, -p2.y); shape.lineTo(p3.x, -p3.y); shape.lineTo(p4.x, -p4.y);
                                const g = new THREE.ShapeGeometry(shape); g.rotateX(-Math.PI / 2);
                                const m = new THREE.Mesh(g, roadMat); m.position.y = 0.1; m.receiveShadow = true; networkGroup.add(m);
                            }
                        }
                    }
                    if (name === 'PolygonGeometry') {
                        const pts = findChildren(all[i], 'Point');
                        if (pts.length > 2) {
                            const points = [];
                            pts.forEach(p => { points.push({ x: parseFloat(getVal(p, 'x')), y: -parseFloat(getVal(p, 'y')) }); });
                            const shape = new THREE.Shape(); shape.moveTo(points[0].x, -points[0].y);
                            for (let k = 1; k < points.length; k++) shape.lineTo(points[k].x, -points[k].y);
                            const g = new THREE.ShapeGeometry(shape); g.rotateX(-Math.PI / 2);
                            const m = new THREE.Mesh(g, juncMat); m.position.y = 0.12; m.receiveShadow = true; networkGroup.add(m);
                        }
                    }
                }

                // Basemap
                let bgNode = null;
                for (let i = 0; i < all.length; i++) if ((all[i].localName || all[i].nodeName.split(':').pop()) === 'Background') bgNode = all[i];
                if (bgNode) {
                    const tiles = findChildren(bgNode, 'Tile');
                    tiles.forEach(t => {
                        const rect = findChildren(t, 'Rectangle')[0];
                        const start = findChildren(rect, 'Start')[0];
                        const end = findChildren(rect, 'End')[0];
                        const img = findChildren(t, 'Image')[0];
                        const b64 = getVal(img, 'binaryData').replace(/\s/g, '');
                        const type = getVal(img, 'type').toUpperCase();
                        const mime = (type === 'JPG' || type === 'JPEG') ? 'jpeg' : 'png';
                        const image = new Image();
                        image.src = `data:image/${mime};base64,${b64}`;
                        image.onload = () => {
                            const tex = new THREE.Texture(image);
                            tex.flipY = false; tex.rotation = Math.PI; tex.center.set(0.5, 0.5); tex.needsUpdate = true;

                            const p1x = parseFloat(getVal(start, 'x')), p1y = -parseFloat(getVal(start, 'y'));
                            const p2x = parseFloat(getVal(end, 'x')), p2y = -parseFloat(getVal(end, 'y'));
                            const w = Math.abs(p2x - p1x), h = Math.abs(p2y - p1y);
                            const x = Math.min(p1x, p2x) + w / 2, y = Math.min(p1y, p2y) + h / 2;

                            const geom = new THREE.PlaneGeometry(w, h);
                            const uvs = geom.attributes.uv; for (let k = 0; k < uvs.count; k++) uvs.setX(k, 1 - uvs.getX(k));

                            const m = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide, depthWrite: false }));
                            m.rotation.x = -Math.PI / 2; m.position.set(x, -0.2, y); basemapGroup.add(m);
                        };
                    });
                }

                resolve({ minX, minY, maxX, maxY });
            });
        }

        init();
    </script>
</body>

</html>